declare module 'rxjs' {
// Generated by dts-bundle v0.7.3

export { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
export { ConnectableObservable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/ConnectableObservable';
export { GroupedObservable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/operators/groupBy';
export { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
export { observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/symbol/observable';
export { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
export { BehaviorSubject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/BehaviorSubject';
export { ReplaySubject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/ReplaySubject';
export { AsyncSubject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/AsyncSubject';
export { asap as asapScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/asap';
export { async as asyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/async';
export { queue as queueScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/queue';
export { animationFrame as animationFrameScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/animationFrame';
export { VirtualTimeScheduler, VirtualAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/VirtualTimeScheduler';
export { Scheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Scheduler';
export { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
export { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
export { Notification } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Notification';
export { pipe } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/pipe';
export { noop } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/noop';
export { identity } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/identity';
export { isObservable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/isObservable';
export { ArgumentOutOfRangeError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/ArgumentOutOfRangeError';
export { EmptyError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/EmptyError';
export { ObjectUnsubscribedError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/ObjectUnsubscribedError';
export { UnsubscriptionError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/UnsubscriptionError';
export { TimeoutError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/util/TimeoutError';
export { bindCallback } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/bindCallback';
export { bindNodeCallback } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/bindNodeCallback';
export { combineLatest } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/combineLatest';
export { concat } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/concat';
export { defer } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/defer';
export { empty } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/empty';
export { forkJoin } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/forkJoin';
export { from } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/from';
export { fromEvent } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/fromEvent';
export { fromEventPattern } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/fromEventPattern';
export { generate } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/generate';
export { iif } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/iif';
export { interval } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/interval';
export { merge } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/merge';
export { never } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/never';
export { of } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/of';
export { onErrorResumeNext } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/onErrorResumeNext';
export { pairs } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/pairs';
export { race } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/race';
export { range } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/range';
export { throwError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/throwError';
export { timer } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/timer';
export { using } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/using';
export { zip } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/zip';
export { EMPTY } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/empty';
export { NEVER } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/never';
export * from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export { config } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/config';

import { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { iif } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/iif';
import { throwError } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/observable/throwError';
/**
    * A representation of any set of values over any amount of time. This is the most basic building block
    * of RxJS.
    *
    * @class Observable<T>
    */
export declare class Observable<T> implements Subscribable<T> {
        /** Internal implementation detail, do not use directly. */
        _isScalar: boolean;
        /** @deprecated This is an internal implementation detail, do not use. */
        source: Observable<any>;
        /** @deprecated This is an internal implementation detail, do not use. */
        operator: Operator<any, T>;
        /**
            * @constructor
            * @param {Function} subscribe the function that is called when the Observable is
            * initially subscribed to. This function is given a Subscriber, to which new values
            * can be `next`ed, or an `error` method can be called to raise an error, or
            * `complete` can be called to notify of a successful completion.
            */
        constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic);
        /**
            * Creates a new cold Observable by calling the Observable constructor
            * @static true
            * @owner Observable
            * @method create
            * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
            * @return {Observable} a new cold observable
            * @nocollapse
            */
        static create: Function;
        /**
            * Creates a new Observable, with this Observable as the source, and the passed
            * operator defined as the new observable's operator.
            * @method lift
            * @param {Operator} operator the operator defining the operation to take on the observable
            * @return {Observable} a new observable with the Operator applied
            */
        lift<R>(operator: Operator<T, R>): Observable<R>;
        subscribe(observer?: PartialObserver<T>): Subscription;
        subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
        /** @deprecated This is an internal implementation detail, do not use. */
        _trySubscribe(sink: Subscriber<T>): TeardownLogic;
        /**
            * @method forEach
            * @param {Function} next a handler for each value emitted by the observable
            * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
            * @return {Promise} a promise that either resolves on observable completion or
            *  rejects with the handled error
            */
        forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>;
        /** @internal This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<any>): TeardownLogic;
        /**
            * @nocollapse
            * @deprecated In favor of iif creation function: import { iif } from 'rxjs';
            */
        static if: typeof iif;
        /**
            * @nocollapse
            * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';
            */
        static throw: typeof throwError;
        pipe(): Observable<T>;
        pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;
        pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;
        pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;
        pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;
        pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;
        pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;
        pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;
        pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;
        pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;
        pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;
        toPromise<T>(this: Observable<T>): Promise<T>;
        toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;
        toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;
}

import { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
  * @class ConnectableObservable<T>
  */
export declare class ConnectableObservable<T> extends Observable<T> {
    source: Observable<T>;
    protected subjectFactory: () => Subject<T>;
    protected _subject: Subject<T>;
    protected _refCount: number;
    protected _connection: Subscription;
    /** @internal */
    _isComplete: boolean;
    constructor(source: Observable<T>, subjectFactory: () => Subject<T>);
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber<T>): Subscription;
    protected getSubject(): Subject<T>;
    connect(): Subscription;
    refCount(): Observable<T>;
}
export declare const connectableObservableDescriptor: PropertyDescriptorMap;

import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
import { OperatorFunction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;
export declare function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;
export declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;
export declare function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;
export interface RefCountSubscription {
    count: number;
    unsubscribe: () => void;
    closed: boolean;
    attemptedToUnsubscribe: boolean;
}
/**
  * An Observable representing values belonging to the same group represented by
  * a common key. The values emitted by a GroupedObservable come from the source
  * Observable. The common key is available as the field `key` on a
  * GroupedObservable instance.
  *
  * @class GroupedObservable<K, T>
  */
export declare class GroupedObservable<K, T> extends Observable<T> {
    key: K;
    /** @deprecated Do not construct this type. Internal use only */
    constructor(key: K, groupSubject: Subject<T>, refCountSubscription?: RefCountSubscription);
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber<T>): Subscription;
}

import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { TeardownLogic } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export interface Operator<T, R> {
    call(subscriber: Subscriber<R>, source: any): TeardownLogic;
}

/** Symbol.observable addition */
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
/** Symbol.observable or a string "@@observable". Used for interop */
export declare const observable: string | symbol;

import { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { Observer, SubscriptionLike, TeardownLogic } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
    * @class SubjectSubscriber<T>
    */
export declare class SubjectSubscriber<T> extends Subscriber<T> {
        protected destination: Subject<T>;
        constructor(destination: Subject<T>);
}
/**
    * A Subject is a special type of Observable that allows values to be
    * multicasted to many Observables. Subjects are like EventEmitters.
    *
    * Every Subject is an Observable and an Observer. You can subscribe to a
    * Subject, and you can call next to feed values as well as error and complete.
    *
    * @class Subject<T>
    */
export declare class Subject<T> extends Observable<T> implements SubscriptionLike {
        observers: Observer<T>[];
        closed: boolean;
        isStopped: boolean;
        hasError: boolean;
        thrownError: any;
        constructor();
        /**@nocollapse */
        static create: Function;
        lift<R>(operator: Operator<T, R>): Observable<R>;
        next(value?: T): void;
        error(err: any): void;
        complete(): void;
        unsubscribe(): void;
        /** @deprecated This is an internal implementation detail, do not use. */
        _trySubscribe(subscriber: Subscriber<T>): TeardownLogic;
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
        /**
            * Creates a new Observable with this Subject as the source. You can do this
            * to create customize Observer-side logic of the Subject and conceal it from
            * code that uses the Observable.
            * @return {Observable} Observable that the Subject casts to
            */
        asObservable(): Observable<T>;
}
/**
    * @class AnonymousSubject<T>
    */
export declare class AnonymousSubject<T> extends Subject<T> {
        protected destination?: Observer<T>;
        constructor(destination?: Observer<T>, source?: Observable<T>);
        next(value: T): void;
        error(err: any): void;
        complete(): void;
        /** @deprecated This is an internal implementation detail, do not use. */
        _subscribe(subscriber: Subscriber<T>): Subscription;
}

import { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
  * A variant of Subject that requires an initial value and emits its current
  * value whenever it is subscribed to.
  *
  * @class BehaviorSubject<T>
  */
export declare class BehaviorSubject<T> extends Subject<T> {
    constructor(_value: T);
    readonly value: T;
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber<T>): Subscription;
    getValue(): T;
    next(value: T): void;
}

import { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
  * A variant of Subject that "replays" or emits old values to new subscribers.
  * It buffers a set number of values and will emit those values immediately to
  * any new subscribers in addition to emitting new values to existing subscribers.
  *
  * @class ReplaySubject<T>
  */
export declare class ReplaySubject<T> extends Subject<T> {
    constructor(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike);
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber<T>): Subscription;
    _getNow(): number;
}

import { Subject } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subject';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
  * A variant of Subject that only emits a value when it completes. It will emit
  * its latest value to all its observers on completion.
  *
  * @class AsyncSubject<T>
  */
export declare class AsyncSubject<T> extends Subject<T> {
    /** @deprecated This is an internal implementation detail, do not use. */
    _subscribe(subscriber: Subscriber<any>): Subscription;
    next(value: T): void;
    error(error: any): void;
    complete(): void;
}

import { AsapScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsapScheduler';
/**
  *
  * Asap Scheduler
  *
  * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
  *
  * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task
  * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
  * code to end and then it will try to execute given task as fast as possible.
  *
  * `asap` scheduler will do its best to minimize time between end of currently executing code
  * and start of scheduled task. This makes it best candidate for performing so called "deferring".
  * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
  * some (although minimal) unwanted delay.
  *
  * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
  * after currently executing code. In particular, if some task was also scheduled with `asap` before,
  * that task will execute first. That being said, if you need to schedule task asynchronously, but
  * as soon as possible, `asap` scheduler is your best bet.
  *
  * ## Example
  * Compare async and asap scheduler<
  * ```javascript
  * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
  * Rx.Scheduler.asap.schedule(() => console.log('asap'));
  *
  * // Logs:
  * // "asap"
  * // "async"
  * // ... but 'asap' goes first!
  * ```
  * @static true
  * @name asap
  * @owner Scheduler
  */
export declare const asap: AsapScheduler;

import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
/**
  *
  * Async Scheduler
  *
  * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
  *
  * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
  * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
  * in intervals.
  *
  * If you just want to "defer" task, that is to perform it right after currently
  * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
  * better choice will be the {@link asapScheduler} scheduler.
  *
  * ## Examples
  * Use async scheduler to delay task
  * ```javascript
  * const task = () => console.log('it works!');
  *
  * Rx.Scheduler.async.schedule(task, 2000);
  *
  * // After 2 seconds logs:
  * // "it works!"
  * ```
  *
  * Use async scheduler to repeat task in intervals
  * ```javascript
  * function task(state) {
  *   console.log(state);
  *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
  *                                   // which we reschedule with new state and delay
  * }
  *
  * Rx.Scheduler.async.schedule(task, 3000, 0);
  *
  * // Logs:
  * // 0 after 3s
  * // 1 after 4s
  * // 2 after 5s
  * // 3 after 6s
  * ```
  *
  * @static true
  * @name async
  * @owner Scheduler
  */
export declare const async: AsyncScheduler;

import { QueueScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/QueueScheduler';
/**
  *
  * Queue Scheduler
  *
  * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
  *
  * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.
  *
  * When used without delay, it schedules given task synchronously - executes it right when
  * it is scheduled. However when called recursively, that is when inside the scheduled task,
  * another task is scheduled with queue scheduler, instead of executing immediately as well,
  * that task will be put on a queue and wait for current one to finish.
  *
  * This means that when you execute task with `queue` scheduler, you are sure it will end
  * before any other task scheduled with that scheduler will start.
  *
  * ## Examples
  * Schedule recursively first, then do something
  * ```javascript
  * Rx.Scheduler.queue.schedule(() => {
  *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
  *
  *   console.log('first');
  * });
  *
  * // Logs:
  * // "first"
  * // "second"
  * ```
  *
  * Reschedule itself recursively
  * ```javascript
  * Rx.Scheduler.queue.schedule(function(state) {
  *   if (state !== 0) {
  *     console.log('before', state);
  *     this.schedule(state - 1); // `this` references currently executing Action,
  *                               // which we reschedule with new state
  *     console.log('after', state);
  *   }
  * }, 0, 3);
  *
  * // In scheduler that runs recursively, you would expect:
  * // "before", 3
  * // "before", 2
  * // "before", 1
  * // "after", 1
  * // "after", 2
  * // "after", 3
  *
  * // But with queue it logs:
  * // "before", 3
  * // "after", 3
  * // "before", 2
  * // "after", 2
  * // "before", 1
  * // "after", 1
  * ```
  *
  * @static true
  * @name queue
  * @owner Scheduler
  */
export declare const queue: QueueScheduler;

import { AnimationFrameScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AnimationFrameScheduler';
/**
  *
  * Animation Frame Scheduler
  *
  * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
  *
  * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler
  * behaviour.
  *
  * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
  * It makes sure scheduled task will happen just before next browser content repaint,
  * thus performing animations as efficiently as possible.
  *
  * ## Example
  * Schedule div height animation
  * ```javascript
  * const div = document.querySelector('.some-div');
  *
  * Rx.Scheduler.animationFrame.schedule(function(height) {
  *   div.style.height = height + "px";
  *
  *   this.schedule(height + 1);  // `this` references currently executing Action,
  *                               // which we reschedule with new state
  * }, 0, 0);
  *
  * // You will see .some-div element growing in height
  * ```
  *
  * @static true
  * @name animationFrame
  * @owner Scheduler
  */
export declare const animationFrame: AnimationFrameScheduler;

import { AsyncAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncAction';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
import { SchedulerAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare class VirtualTimeScheduler extends AsyncScheduler {
        maxFrames: number;
        protected static frameTimeFactor: number;
        frame: number;
        index: number;
        constructor(SchedulerAction?: typeof AsyncAction, maxFrames?: number);
        /**
            * Prompt the Scheduler to execute all of its queued actions, therefore
            * clearing its queue.
            * @return {void}
            */
        flush(): void;
}
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @nodoc
    */
export declare class VirtualAction<T> extends AsyncAction<T> {
        protected scheduler: VirtualTimeScheduler;
        protected work: (this: SchedulerAction<T>, state?: T) => void;
        protected index: number;
        protected active: boolean;
        constructor(scheduler: VirtualTimeScheduler, work: (this: SchedulerAction<T>, state?: T) => void, index?: number);
        schedule(state?: T, delay?: number): Subscription;
        protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
        protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay?: number): any;
        protected _execute(state: T, delay: number): any;
        static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>): 1 | -1 | 0;
}

import { Action } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/Action';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { SchedulerLike, SchedulerAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
    * An execution context and a data structure to order tasks and schedule their
    * execution. Provides a notion of (potentially virtual) time, through the
    * `now()` getter method.
    *
    * Each unit of work in a Scheduler is called an `Action`.
    *
    * ```ts
    * class Scheduler {
    *   now(): number;
    *   schedule(work, delay?, state?): Subscription;
    * }
    * ```
    *
    * @class Scheduler
    * @deprecated Scheduler is an internal implementation detail of RxJS, and
    * should not be used directly. Rather, create your own class and implement
    * {@link SchedulerLike}
    */
export declare class Scheduler implements SchedulerLike {
        /**
            * Note: the extra arrow function wrapper is to make testing by overriding
            * Date.now easier.
            * @nocollapse
            */
        static now: () => number;
        constructor(SchedulerAction: typeof Action, now?: () => number);
        /**
            * A getter method that returns a number representing the current time
            * (at the time this function was called) according to the scheduler's own
            * internal clock.
            * @return {number} A number that represents the current time. May or may not
            * have a relation to wall-clock time. May or may not refer to a time unit
            * (e.g. milliseconds).
            */
        now: () => number;
        /**
            * Schedules a function, `work`, for execution. May happen at some point in
            * the future, according to the `delay` parameter, if specified. May be passed
            * some context object, `state`, which will be passed to the `work` function.
            *
            * The given arguments will be processed an stored as an Action object in a
            * queue of actions.
            *
            * @param {function(state: ?T): ?Subscription} work A function representing a
            * task, or some unit of work to be executed by the Scheduler.
            * @param {number} [delay] Time to wait before executing the work, where the
            * time unit is implicit and defined by the Scheduler itself.
            * @param {T} [state] Some contextual data that the `work` function uses when
            * called by the Scheduler.
            * @return {Subscription} A subscription in order to be able to unsubscribe
            * the scheduled work.
            */
        schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
}

import { SubscriptionLike, TeardownLogic } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
    * Represents a disposable resource, such as the execution of an Observable. A
    * Subscription has one important method, `unsubscribe`, that takes no argument
    * and just disposes the resource held by the subscription.
    *
    * Additionally, subscriptions may be grouped together through the `add()`
    * method, which will attach a child Subscription to the current Subscription.
    * When a Subscription is unsubscribed, all its children (and its grandchildren)
    * will be unsubscribed as well.
    *
    * @class Subscription
    */
export declare class Subscription implements SubscriptionLike {
        /** @nocollapse */
        static EMPTY: Subscription;
        /**
            * A flag to indicate whether this Subscription has already been unsubscribed.
            * @type {boolean}
            */
        closed: boolean;
        /** @internal */
        protected _parent: Subscription;
        /** @internal */
        protected _parents: Subscription[];
        /**
            * @param {function(): void} [unsubscribe] A function describing how to
            * perform the disposal of resources when the `unsubscribe` method is called.
            */
        constructor(unsubscribe?: () => void);
        /**
            * Disposes the resources held by the subscription. May, for instance, cancel
            * an ongoing Observable execution or cancel any other type of work that
            * started when the Subscription was created.
            * @return {void}
            */
        unsubscribe(): void;
        /**
            * Adds a tear down to be called during the unsubscribe() of this
            * Subscription.
            *
            * If the tear down being added is a subscription that is already
            * unsubscribed, is the same reference `add` is being called on, or is
            * `Subscription.EMPTY`, it will not be added.
            *
            * If this subscription is already in an `closed` state, the passed
            * tear down logic will be executed immediately.
            *
            * @param {TeardownLogic} teardown The additional logic to execute on
            * teardown.
            * @return {Subscription} Returns the Subscription used or created to be
            * added to the inner subscriptions list. This Subscription can be used with
            * `remove()` to remove the passed teardown logic from the inner subscriptions
            * list.
            */
        add(teardown: TeardownLogic): Subscription;
        /**
            * Removes a Subscription from the internal list of subscriptions that will
            * unsubscribe during the unsubscribe process of this Subscription.
            * @param {Subscription} subscription The subscription to remove.
            * @return {void}
            */
        remove(subscription: Subscription): void;
}

import { Observer, PartialObserver } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
    * Implements the {@link Observer} interface and extends the
    * {@link Subscription} class. While the {@link Observer} is the public API for
    * consuming the values of an {@link Observable}, all Observers get converted to
    * a Subscriber, in order to provide Subscription-like capabilities such as
    * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
    * implementing operators, but it is rarely used as a public API.
    *
    * @class Subscriber<T>
    */
export declare class Subscriber<T> extends Subscription implements Observer<T> {
        /**
            * A static factory for a Subscriber, given a (potentially partial) definition
            * of an Observer.
            * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
            * @param {function(e: ?any): void} [error] The `error` callback of an
            * Observer.
            * @param {function(): void} [complete] The `complete` callback of an
            * Observer.
            * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
            * Observer represented by the given arguments.
            * @nocollapse
            */
        static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;
        /** @internal */ syncErrorValue: any;
        /** @internal */ syncErrorThrown: boolean;
        /** @internal */ syncErrorThrowable: boolean;
        protected isStopped: boolean;
        protected destination: PartialObserver<any> | Subscriber<any>;
        private _parentSubscription;
        /**
            * @param {Observer|function(value: T): void} [destinationOrNext] A partially
            * defined Observer or a `next` callback function.
            * @param {function(e: ?any): void} [error] The `error` callback of an
            * Observer.
            * @param {function(): void} [complete] The `complete` callback of an
            * Observer.
            */
        constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
        /**
            * The {@link Observer} callback to receive notifications of type `next` from
            * the Observable, with a value. The Observable may call this method 0 or more
            * times.
            * @param {T} [value] The `next` value.
            * @return {void}
            */
        next(value?: T): void;
        /**
            * The {@link Observer} callback to receive notifications of type `error` from
            * the Observable, with an attached `Error`. Notifies the Observer that
            * the Observable has experienced an error condition.
            * @param {any} [err] The `error` exception.
            * @return {void}
            */
        error(err?: any): void;
        /**
            * The {@link Observer} callback to receive a valueless notification of type
            * `complete` from the Observable. Notifies the Observer that the Observable
            * has finished sending push-based notifications.
            * @return {void}
            */
        complete(): void;
        unsubscribe(): void;
        protected _next(value: T): void;
        protected _error(err: any): void;
        protected _complete(): void;
        /** @deprecated This is an internal implementation detail, do not use. */
        _unsubscribeAndRecycle(): Subscriber<T>;
}
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @ignore
    * @extends {Ignored}
    */
export declare class SafeSubscriber<T> extends Subscriber<T> {
        constructor(_parentSubscriber: Subscriber<T>, observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (e?: any) => void, complete?: () => void);
        next(value?: T): void;
        error(err?: any): void;
        complete(): void;
        /** @internal This is an internal implementation detail, do not use. */
        _unsubscribe(): void;
}

import { PartialObserver } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
/**
    * Represents a push-based event or value that an {@link Observable} can emit.
    * This class is particularly useful for operators that manage notifications,
    * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
    * others. Besides wrapping the actual delivered value, it also annotates it
    * with metadata of, for instance, what type of push message it is (`next`,
    * `error`, or `complete`).
    *
    * @see {@link materialize}
    * @see {@link dematerialize}
    * @see {@link observeOn}
    *
    * @class Notification<T>
    */
export declare class Notification<T> {
        kind: string;
        value?: T;
        error?: any;
        hasValue: boolean;
        constructor(kind: string, value?: T, error?: any);
        /**
            * Delivers to the given `observer` the value wrapped by this Notification.
            * @param {Observer} observer
            * @return
            */
        observe(observer: PartialObserver<T>): any;
        /**
            * Given some {@link Observer} callbacks, deliver the value represented by the
            * current Notification to the correctly corresponding callback.
            * @param {function(value: T): void} next An Observer `next` callback.
            * @param {function(err: any): void} [error] An Observer `error` callback.
            * @param {function(): void} [complete] An Observer `complete` callback.
            * @return {any}
            */
        do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any;
        /**
            * Takes an Observer or its individual callback functions, and calls `observe`
            * or `do` methods accordingly.
            * @param {Observer|function(value: T): void} nextOrObserver An Observer or
            * the `next` callback.
            * @param {function(err: any): void} [error] An Observer `error` callback.
            * @param {function(): void} [complete] An Observer `complete` callback.
            * @return {any}
            */
        accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void): any;
        /**
            * Returns a simple Observable that just delivers the notification represented
            * by this Notification instance.
            * @return {any}
            */
        toObservable(): Observable<T>;
        /**
            * A shortcut to create a Notification instance of the type `next` from a
            * given value.
            * @param {T} value The `next` value.
            * @return {Notification<T>} The "next" Notification representing the
            * argument.
            * @nocollapse
            */
        static createNext<T>(value: T): Notification<T>;
        /**
            * A shortcut to create a Notification instance of the type `error` from a
            * given error.
            * @param {any} [err] The `error` error.
            * @return {Notification<T>} The "error" Notification representing the
            * argument.
            * @nocollapse
            */
        static createError<T>(err?: any): Notification<T>;
        /**
            * A shortcut to create a Notification instance of the type `complete`.
            * @return {Notification<any>} The valueless "complete" Notification.
            * @nocollapse
            */
        static createComplete(): Notification<any>;
}

import { UnaryFunction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function pipe<T>(): UnaryFunction<T, T>;
export declare function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;
export declare function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;
export declare function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;
export declare function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;
export declare function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;
export declare function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;
export declare function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;
export declare function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;
export declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;
export declare function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;
/** @internal */
export declare function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R>;

export declare function noop(): void;

export declare function identity<T>(x: T): T;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
/**
  * Tests to see if the object is an RxJS {@link Observable}
  * @param obj the object to test
  */
export declare function isObservable<T>(obj: any): obj is Observable<T>;

export interface ArgumentOutOfRangeError extends Error {
}
export interface ArgumentOutOfRangeErrorCtor {
    new (): ArgumentOutOfRangeError;
}
/**
  * An error thrown when an element was queried at a certain index of an
  * Observable, but no such index or position exists in that sequence.
  *
  * @see {@link elementAt}
  * @see {@link take}
  * @see {@link takeLast}
  *
  * @class ArgumentOutOfRangeError
  */
export declare const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor;

export interface EmptyError extends Error {
}
export interface EmptyErrorCtor {
    new (): EmptyError;
}
/**
  * An error thrown when an Observable or a sequence was queried but has no
  * elements.
  *
  * @see {@link first}
  * @see {@link last}
  * @see {@link single}
  *
  * @class EmptyError
  */
export declare const EmptyError: EmptyErrorCtor;

export interface ObjectUnsubscribedError extends Error {
}
export interface ObjectUnsubscribedErrorCtor {
    new (): ObjectUnsubscribedError;
}
/**
  * An error thrown when an action is invalid because the object has been
  * unsubscribed.
  *
  * @see {@link Subject}
  * @see {@link BehaviorSubject}
  *
  * @class ObjectUnsubscribedError
  */
export declare const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor;

export interface UnsubscriptionError extends Error {
    readonly errors: any[];
}
export interface UnsubscriptionErrorCtor {
    new (errors: any[]): UnsubscriptionError;
}
/**
  * An error thrown when one or more errors have occurred during the
  * `unsubscribe` of a {@link Subscription}.
  */
export declare const UnsubscriptionError: UnsubscriptionErrorCtor;

export interface TimeoutError extends Error {
}
export interface TimeoutErrorCtor {
    new (): TimeoutError;
}
/**
  * An error thrown when duetime elapses.
  *
  * @see {@link timeout}
  *
  * @class TimeoutError
  */
export declare const TimeoutError: TimeoutErrorCtor;

import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
/** @deprecated resultSelector is no longer supported, use a mapping function. */
export declare function bindCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;
export declare function bindCallback<R1, R2, R3, R4>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): () => Observable<any[]>;
export declare function bindCallback<R1, R2, R3>(callbackFunc: (callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;
export declare function bindCallback<R1, R2>(callbackFunc: (callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;
export declare function bindCallback<R1>(callbackFunc: (callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;
export declare function bindCallback(callbackFunc: (callback: () => any) => any, scheduler?: SchedulerLike): () => Observable<void>;
export declare function bindCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<any[]>;
export declare function bindCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;
export declare function bindCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;
export declare function bindCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;
export declare function bindCallback<A1>(callbackFunc: (arg1: A1, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;
export declare function bindCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<any[]>;
export declare function bindCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;
export declare function bindCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;
export declare function bindCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;
export declare function bindCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;
export declare function bindCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<any[]>;
export declare function bindCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;
export declare function bindCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;
export declare function bindCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;
export declare function bindCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;
export declare function bindCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<any[]>;
export declare function bindCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;
export declare function bindCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;
export declare function bindCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;
export declare function bindCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;
export declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<any[]>;
export declare function bindCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;
export declare function bindCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;
export declare function bindCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;
export declare function bindCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: () => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;
export declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((result: R) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R>;
export declare function bindCallback<A, R>(callbackFunc: (...args: Array<A | ((...results: R[]) => any)>) => any, scheduler?: SchedulerLike): (...args: A[]) => Observable<R[]>;
export declare function bindCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/** @deprecated resultSelector is deprecated, pipe to map instead */
export declare function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;
export declare function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;
export declare function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;
export declare function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;
export declare function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;
export declare function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;
export declare function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;
export declare function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;
export declare function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;
export declare function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;
export declare function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;
export declare function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;
export declare function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;
export declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;
export declare function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;
export declare function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;
export declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;
export declare function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;
export declare function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;
export declare function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>;
export declare function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { OuterSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/OuterSubscriber';
import { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
import { InnerSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/InnerSubscriber';
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R, scheduler?: SchedulerLike): Observable<R>;
export declare function combineLatest<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<[T, T2]>;
export declare function combineLatest<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<[T, T2, T3]>;
export declare function combineLatest<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4]>;
export declare function combineLatest<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5]>;
export declare function combineLatest<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<[T, T2, T3, T4, T5, T6]>;
export declare function combineLatest<T>(array: ObservableInput<T>[], scheduler?: SchedulerLike): Observable<T[]>;
export declare function combineLatest<R>(array: ObservableInput<any>[], scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R, scheduler?: SchedulerLike): Observable<R>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function combineLatest<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R, scheduler?: SchedulerLike): Observable<R>;
export declare function combineLatest<T>(...observables: Array<ObservableInput<T> | SchedulerLike>): Observable<T[]>;
export declare function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R) | SchedulerLike>): Observable<R>;
export declare function combineLatest<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R) | SchedulerLike>): Observable<R>;
export declare class CombineLatestOperator<T, R> implements Operator<T, R> {
        constructor(resultSelector?: (...values: Array<any>) => R);
        call(subscriber: Subscriber<R>, source: any): any;
}
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @ignore
    * @extends {Ignored}
    */
export declare class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {
        constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R);
        protected _next(observable: any): void;
        protected _complete(): void;
        notifyComplete(unused: Subscriber<R>): void;
        notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
}

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function concat<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
export declare function concat<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;
export declare function concat<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
export declare function concat<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
export declare function concat<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
export declare function concat<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
export declare function concat<T>(...observables: (ObservableInput<T> | SchedulerLike)[]): Observable<T>;
export declare function concat<T, R>(...observables: (ObservableInput<any> | SchedulerLike)[]): Observable<R>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SubscribableOrPromise } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Creates an Observable that, on subscribe, calls an Observable factory to
  * make an Observable for each new Observer.
  *
  * <span class="informal">Creates the Observable lazily, that is, only when it
  * is subscribed.
  * </span>
  *
  * ![](defer.png)
  *
  * `defer` allows you to create the Observable only when the Observer
  * subscribes, and create a fresh Observable for each Observer. It waits until
  * an Observer subscribes to it, and then it generates an Observable,
  * typically with an Observable factory function. It does this afresh for each
  * subscriber, so although each subscriber may think it is subscribing to the
  * same Observable, in fact each subscriber gets its own individual
  * Observable.
  *
  * ## Example
  * ### Subscribe to either an Observable of clicks or an Observable of interval, at random
  * ```javascript
  * const clicksOrInterval = defer(function () {
  *   return Math.random() > 0.5
  *     ? fromEvent(document, 'click')
  *     : interval(1000);
  * });
  * clicksOrInterval.subscribe(x => console.log(x));
  *
  * // Results in the following behavior:
  * // If the result of Math.random() is greater than 0.5 it will listen
  * // for clicks anywhere on the "document"; when document is clicked it
  * // will log a MouseEvent object to the console. If the result is less
  * // than 0.5 it will emit ascending numbers, one every second(1000ms).
  * ```
  *
  * @see {@link Observable}
  *
  * @param {function(): SubscribableOrPromise} observableFactory The Observable
  * factory function to invoke for each Observer that subscribes to the output
  * Observable. May also return a Promise, which will be converted on the fly
  * to an Observable.
  * @return {Observable} An Observable whose Observers' subscriptions trigger
  * an invocation of the given Observable factory function.
  * @static true
  * @name defer
  * @owner Observable
  */
export declare function defer<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
    * The same Observable instance returned by any call to {@link empty} without a
    * `scheduler`. It is preferrable to use this over `empty()`.
    */
export declare const EMPTY: Observable<never>;
/**
    * Creates an Observable that emits no items to the Observer and immediately
    * emits a complete notification.
    *
    * <span class="informal">Just emits 'complete', and nothing else.
    * </span>
    *
    * ![](empty.png)
    *
    * This static operator is useful for creating a simple Observable that only
    * emits the complete notification. It can be used for composing with other
    * Observables, such as in a {@link mergeMap}.
    *
    * ## Examples
    * ### Emit the number 7, then complete
    * ```javascript
    * const result = empty().pipe(startWith(7));
    * result.subscribe(x => console.log(x));
    * ```
    *
    * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'
    * ```javascript
    * const interval$ = interval(1000);
    * result = interval$.pipe(
    *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),
    * );
    * result.subscribe(x => console.log(x));
    *
    * // Results in the following to the console:
    * // x is equal to the count on the interval eg(0,1,2,3,...)
    * // x will occur every 1000ms
    * // if x % 2 is equal to 1 print abc
    * // if x % 2 is not equal to 1 nothing will be output
    * ```
    *
    * @see {@link Observable}
    * @see {@link never}
    * @see {@link of}
    * @see {@link throwError}
    *
    * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
    * the emission of the complete notification.
    * @return {Observable} An "empty" Observable: emits only the complete
    * notification.
    * @static true
    * @name empty
    * @owner Observable
    * @deprecated Deprecated in favor of using {@link index/EMPTY} constant.
    */
export declare function empty(scheduler?: SchedulerLike): Observable<never>;
export declare function emptyScheduled(scheduler: SchedulerLike): Observable<never>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function forkJoin<T>(sources: [ObservableInput<T>]): Observable<T[]>;
export declare function forkJoin<T, T2>(sources: [ObservableInput<T>, ObservableInput<T2>]): Observable<[T, T2]>;
export declare function forkJoin<T, T2, T3>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>]): Observable<[T, T2, T3]>;
export declare function forkJoin<T, T2, T3, T4>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>]): Observable<[T, T2, T3, T4]>;
export declare function forkJoin<T, T2, T3, T4, T5>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>]): Observable<[T, T2, T3, T4, T5]>;
export declare function forkJoin<T, T2, T3, T4, T5, T6>(sources: [ObservableInput<T>, ObservableInput<T2>, ObservableInput<T3>, ObservableInput<T4>, ObservableInput<T5>, ObservableInput<T6>]): Observable<[T, T2, T3, T4, T5, T6]>;
export declare function forkJoin<T>(sources: Array<ObservableInput<T>>): Observable<T[]>;
export declare function forkJoin<T>(v1: ObservableInput<T>): Observable<T[]>;
export declare function forkJoin<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
export declare function forkJoin<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
export declare function forkJoin<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
export declare function forkJoin<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
export declare function forkJoin<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
/** @deprecated resultSelector is deprecated, pipe to map instead */
export declare function forkJoin(...args: Array<ObservableInput<any> | Function>): Observable<any>;
export declare function forkJoin<T>(...sources: ObservableInput<T>[]): Observable<T[]>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
export declare function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
export interface NodeStyleEventEmitter {
    addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;
    removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;
}
export declare type NodeEventHandler = (...args: any[]) => void;
export interface NodeCompatibleEventEmitter {
    addListener: (eventName: string, handler: NodeEventHandler) => void | {};
    removeListener: (eventName: string, handler: NodeEventHandler) => void | {};
}
export interface JQueryStyleEventEmitter {
    on: (eventName: string, handler: Function) => void;
    off: (eventName: string, handler: Function) => void;
}
export interface HasEventTargetAddRemove<E> {
    addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | AddEventListenerOptions): void;
    removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: EventListenerOptions | boolean): void;
}
export declare type EventTargetLike<T> = HasEventTargetAddRemove<T> | NodeStyleEventEmitter | NodeCompatibleEventEmitter | JQueryStyleEventEmitter;
export declare type FromEventTarget<T> = EventTargetLike<T> | ArrayLike<EventTargetLike<T>>;
export interface EventListenerOptions {
    capture?: boolean;
    passive?: boolean;
    once?: boolean;
}
export interface AddEventListenerOptions extends EventListenerOptions {
    once?: boolean;
    passive?: boolean;
}
export declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string): Observable<T>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, resultSelector: (...args: any[]) => T): Observable<T>;
export declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions): Observable<T>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function fromEvent<T>(target: FromEventTarget<T>, eventName: string, options: EventListenerOptions, resultSelector: (...args: any[]) => T): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
export declare function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void): Observable<T>;
/** @deprecated resultSelector no longer supported, pipe to map instead */
export declare function fromEventPattern<T>(addHandler: (handler: Function) => any, removeHandler?: (handler: Function, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare type ConditionFunc<S> = (state: S) => boolean;
export declare type IterateFunc<S> = (state: S) => S;
export declare type ResultFunc<S, T> = (state: S) => T;
export interface GenerateBaseOptions<S> {
        /**
            * Initial state.
            */
        initialState: S;
        /**
            * Condition function that accepts state and returns boolean.
            * When it returns false, the generator stops.
            * If not specified, a generator never stops.
            */
        condition?: ConditionFunc<S>;
        /**
            * Iterate function that accepts state and returns new state.
            */
        iterate: IterateFunc<S>;
        /**
            * SchedulerLike to use for generation process.
            * By default, a generator starts immediately.
            */
        scheduler?: SchedulerLike;
}
export interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {
        /**
            * Result selection function that accepts state and returns a value to emit.
            */
        resultSelector: ResultFunc<S, T>;
}
/**
    * Generates an observable sequence by running a state-driven loop
    * producing the sequence's elements, using the specified scheduler
    * to send out observer messages.
    *
    * ![](generate.png)
    *
    * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
    * const res = generate(0, x => x < 10, x => x + 1, x => x);
    *
    * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>
    * const res = generate(1, x => x < 5, x =>  * 2, x => x + 1, asap);
    *
    * @see {@link from}
    * @see {@link Observable}
    *
    * @param {S} initialState Initial state.
    * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
    * @param {function (state: S): S} iterate Iteration step function.
    * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)
    * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.
    * @returns {Observable<T>} The generated sequence.
    */
export declare function generate<T, S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, resultSelector: ResultFunc<S, T>, scheduler?: SchedulerLike): Observable<T>;
/**
    * Generates an Observable by running a state-driven loop
    * that emits an element on each iteration.
    *
    * <span class="informal">Use it instead of nexting values in a for loop.</span>
    *
    * <img src="./img/generate.png" width="100%">
    *
    * `generate` allows you to create stream of values generated with a loop very similar to
    * traditional for loop. First argument of `generate` is a beginning value. Second argument
    * is a function that accepts this value and tests if some condition still holds. If it does,
    * loop continues, if not, it stops. Third value is a function which takes previously defined
    * value and modifies it in some way on each iteration. Note how these three parameters
    * are direct equivalents of three expressions in regular for loop: first expression
    * initializes some state (for example numeric index), second tests if loop can make next
    * iteration (for example if index is lower than 10) and third states how defined value
    * will be modified on every step (index will be incremented by one).
    *
    * Return value of a `generate` operator is an Observable that on each loop iteration
    * emits a value. First, condition function is ran. If it returned true, Observable
    * emits currently stored value (initial value at the first iteration) and then updates
    * that value with iterate function. If at some point condition returned false, Observable
    * completes at that moment.
    *
    * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you
    * to immediately map value that would normally be emitted by an Observable.
    *
    * If you find three anonymous functions in `generate` call hard to read, you can provide
    * single object to the operator instead. That object has properties: `initialState`,
    * `condition`, `iterate` and `resultSelector`, which should have respective values that you
    * would normally pass to `generate`. `resultSelector` is still optional, but that form
    * of calling `generate` allows you to omit `condition` as well. If you omit it, that means
    * condition always holds, so output Observable will never complete.
    *
    * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,
    * scheduler simply comes as a last argument (no matter if there is resultSelector
    * function or not). In case of single-parameter call, you can provide it as a
    * `scheduler` property on object passed to the operator. In both cases scheduler decides when
    * next iteration of the loop will happen and therefore when next value will be emitted
    * by the Observable. For example to ensure that each value is pushed to the observer
    * on separate task in event loop, you could use `async` scheduler. Note that
    * by default (when no scheduler is passed) values are simply emitted synchronously.
    *
    *
    * @example <caption>Use with condition and iterate functions.</caption>
    * const generated = generate(0, x => x < 3, x => x + 1);
    *
    * generated.subscribe(
    *   value => console.log(value),
    *   err => {},
    *   () => console.log('Yo!')
    * );
    *
    * // Logs:
    * // 0
    * // 1
    * // 2
    * // "Yo!"
    *
    *
    * @example <caption>Use with condition, iterate and resultSelector functions.</caption>
    * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);
    *
    * generated.subscribe(
    *   value => console.log(value),
    *   err => {},
    *   () => console.log('Yo!')
    * );
    *
    * // Logs:
    * // 0
    * // 1000
    * // 2000
    * // "Yo!"
    *
    *
    * @example <caption>Use with options object.</caption>
    * const generated = generate({
    *   initialState: 0,
    *   condition(value) { return value < 3; },
    *   iterate(value) { return value + 1; },
    *   resultSelector(value) { return value * 1000; }
    * });
    *
    * generated.subscribe(
    *   value => console.log(value),
    *   err => {},
    *   () => console.log('Yo!')
    * );
    *
    * // Logs:
    * // 0
    * // 1000
    * // 2000
    * // "Yo!"
    *
    * @example <caption>Use options object without condition function.</caption>
    * const generated = generate({
    *   initialState: 0,
    *   iterate(value) { return value + 1; },
    *   resultSelector(value) { return value * 1000; }
    * });
    *
    * generated.subscribe(
    *   value => console.log(value),
    *   err => {},
    *   () => console.log('Yo!') // This will never run.
    * );
    *
    * // Logs:
    * // 0
    * // 1000
    * // 2000
    * // 3000
    * // ...and never stops.
    *
    *
    * @see {@link from}
    * @see {@link create}
    *
    * @param {S} initialState Initial state.
    * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).
    * @param {function (state: S): S} iterate Iteration step function.
    * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.
    * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.
    * @return {Observable<T>} The generated sequence.
    */
export declare function generate<S>(initialState: S, condition: ConditionFunc<S>, iterate: IterateFunc<S>, scheduler?: SchedulerLike): Observable<S>;
/**
    * Generates an observable sequence by running a state-driven loop
    * producing the sequence's elements, using the specified scheduler
    * to send out observer messages.
    * The overload accepts options object that might contain initial state, iterate,
    * condition and scheduler.
    *
    * ![](generate.png)
    *
    * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
    * const res = generate({
    *   initialState: 0,
    *   condition: x => x < 10,
    *   iterate: x => x + 1,
    * });
    *
    * @see {@link from}
    * @see {@link Observable}
    *
    * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.
    * @returns {Observable<S>} The generated sequence.
    */
export declare function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;
/**
    * Generates an observable sequence by running a state-driven loop
    * producing the sequence's elements, using the specified scheduler
    * to send out observer messages.
    * The overload accepts options object that might contain initial state, iterate,
    * condition, result selector and scheduler.
    *
    * ![](generate.png)
    *
    * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>
    * const res = generate({
    *   initialState: 0,
    *   condition: x => x < 10,
    *   iterate: x => x + 1,
    *   resultSelector: x => x,
    * });
    *
    * @see {@link from}
    * @see {@link Observable}
    *
    * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.
    * @returns {Observable<T>} The generated sequence.
    */
export declare function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SubscribableOrPromise } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Decides at subscription time which Observable will actually be subscribed.
  *
  * <span class="informal">`If` statement for Observables.</span>
  *
  * `iif` accepts a condition function and two Observables. When
  * an Observable returned by the operator is subscribed, condition function will be called.
  * Based on what boolean it returns at that moment, consumer will subscribe either to
  * the first Observable (if condition was true) or to the second (if condition was false). Condition
  * function may also not return anything - in that case condition will be evaluated as false and
  * second Observable will be subscribed.
  *
  * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
  * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
  * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
  * to given Observable or not.
  *
  * If you have more complex logic that requires decision between more than two Observables, {@link defer}
  * will probably be a better choice. Actually `iif` can be easily implemented with {@link defer}
  * and exists only for convenience and readability reasons.
  *
  *
  * ## Examples
  * ### Change at runtime which Observable will be subscribed
  * ```javascript
  * let subscribeToFirst;
  * const firstOrSecond = iif(
  *   () => subscribeToFirst,
  *   of('first'),
  *   of('second'),
  * );
  *
  * subscribeToFirst = true;
  * firstOrSecond.subscribe(value => console.log(value));
  *
  * // Logs:
  * // "first"
  *
  * subscribeToFirst = false;
  * firstOrSecond.subscribe(value => console.log(value));
  *
  * // Logs:
  * // "second"
  *
  * ```
  *
  * ### Control an access to an Observable
  * ```javascript
  * let accessGranted;
  * const observableIfYouHaveAccess = iif(
  *   () => accessGranted,
  *   of('It seems you have an access...'), // Note that only one Observable is passed to the operator.
  * );
  *
  * accessGranted = true;
  * observableIfYouHaveAccess.subscribe(
  *   value => console.log(value),
  *   err => {},
  *   () => console.log('The end'),
  * );
  *
  * // Logs:
  * // "It seems you have an access..."
  * // "The end"
  *
  * accessGranted = false;
  * observableIfYouHaveAccess.subscribe(
  *   value => console.log(value),
  *   err => {},
  *   () => console.log('The end'),
  * );
  *
  * // Logs:
  * // "The end"
  * ```
  *
  * @see {@link defer}
  *
  * @param {function(): boolean} condition Condition which Observable should be chosen.
  * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
  * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
  * @return {Observable} Either first or second Observable, depending on condition.
  * @static true
  * @name iif
  * @owner Observable
  */
export declare function iif<T, F>(condition: () => boolean, trueResult?: SubscribableOrPromise<T>, falseResult?: SubscribableOrPromise<F>): Observable<T | F>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Creates an Observable that emits sequential numbers every specified
  * interval of time, on a specified {@link SchedulerLike}.
  *
  * <span class="informal">Emits incremental numbers periodically in time.
  * </span>
  *
  * ![](interval.png)
  *
  * `interval` returns an Observable that emits an infinite sequence of
  * ascending integers, with a constant interval of time of your choosing
  * between those emissions. The first emission is not sent immediately, but
  * only after the first period has passed. By default, this operator uses the
  * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any
  * {@link SchedulerLike} to it.
  *
  * ## Example
  * Emits ascending numbers, one every second (1000ms) up to the number 3
  * ```javascript
  * import { interval } from 'rxjs';
  * import { take } from 'rxjs/operators';
  *
  * const numbers = interval(1000);
  *
  * const takeFourNumbers = numbers.pipe(take(4));
  *
  * takeFourNumbers.subscribe(x => console.log('Next: ', x));
  *
  * // Logs:
  * // Next: 0
  * // Next: 1
  * // Next: 2
  * // Next: 3
  * ```
  *
  * @see {@link timer}
  * @see {@link delay}
  *
  * @param {number} [period=0] The interval size in milliseconds (by default)
  * or the time unit determined by the scheduler's clock.
  * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
  * the emission of values, and providing a notion of "time".
  * @return {Observable} An Observable that emits a sequential number each time
  * interval.
  * @static true
  * @name interval
  * @owner Observable
  */
export declare function interval(period?: number, scheduler?: SchedulerLike): Observable<number>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function merge<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;
export declare function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): Observable<T>;
export declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;
export declare function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2>;
export declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
export declare function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
export declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
export declare function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
export declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
export declare function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
export declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
export declare function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
export declare function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;
export declare function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
/**
    * An Observable that emits no items to the Observer and never completes.
    *
    * ![](never.png)
    *
    * A simple Observable that emits neither values nor errors nor the completion
    * notification. It can be used for testing purposes or for composing with other
    * Observables. Please note that by never emitting a complete notification, this
    * Observable keeps the subscription from being disposed automatically.
    * Subscriptions need to be manually disposed.
    *
    * ##  Example
    * ### Emit the number 7, then never emit anything else (not even complete)
    * ```javascript
    * function info() {
    *   console.log('Will not be called');
    * }
    * const result = NEVER.pipe(startWith(7));
    * result.subscribe(x => console.log(x), info, info);
    *
    * ```
    *
    * @see {@link Observable}
    * @see {@link index/EMPTY}
    * @see {@link of}
    * @see {@link throwError}
    */
export declare const NEVER: Observable<never>;
/**
    * @deprecated Deprecated in favor of using {@link NEVER} constant.
    */
export declare function never(): Observable<never>;

import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
export declare function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;
export declare function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;
export declare function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;
export declare function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;
export declare function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;
export declare function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;
export declare function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;
export declare function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;
export declare function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;
export declare function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { ObservableInput } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
export declare function onErrorResumeNext<R>(v: ObservableInput<R>): Observable<R>;
export declare function onErrorResumeNext<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;
export declare function onErrorResumeNext<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;
export declare function onErrorResumeNext<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;
export declare function onErrorResumeNext<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;
export declare function onErrorResumeNext<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export declare function onErrorResumeNext<R>(array: ObservableInput<any>[]): Observable<R>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerAction, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/**
  * Convert an object into an Observable of `[key, value]` pairs.
  *
  * <span class="informal">Turn entries of an object into a stream.</span>
  *
  * <img src="./img/pairs.png" width="100%">
  *
  * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each
  * emitted array has exactly two elements - the first is a key from the object
  * and the second is a value corresponding to that key. Keys are extracted from
  * an object via `Object.keys` function, which means that they will be only
  * enumerable keys that are present on an object directly - not ones inherited
  * via prototype chain.
  *
  * By default these arrays are emitted synchronously. To change that you can
  * pass a {@link SchedulerLike} as a second argument to `pairs`.
  *
  * @example <caption>Converts a javascript object to an Observable</caption>
  * ```javascript
  * const obj = {
  *   foo: 42,
  *   bar: 56,
  *   baz: 78
  * };
  *
  * pairs(obj)
  * .subscribe(
  *   value => console.log(value),
  *   err => {},
  *   () => console.log('the end!')
  * );
  *
  * // Logs:
  * // ["foo": 42],
  * // ["bar": 56],
  * // ["baz": 78],
  * // "the end!"
  * ```
  *
  * @param {Object} obj The object to inspect and turn into an
  * Observable sequence.
  * @param {Scheduler} [scheduler] An optional IScheduler to schedule
  * when resulting Observable will emit values.
  * @returns {(Observable<Array<string|T>>)} An observable sequence of
  * [key, value] pairs from the object.
  */
export declare function pairs<T>(obj: Object, scheduler?: SchedulerLike): Observable<[string, T]>;
/** @internal */
export declare function dispatch<T>(this: SchedulerAction<any>, state: {
    keys: string[];
    index: number;
    subscriber: Subscriber<[string, T]>;
    subscription: Subscription;
    obj: Object;
}): void;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { TeardownLogic } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { OuterSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/OuterSubscriber';
import { InnerSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/InnerSubscriber';
/**
    * Returns an Observable that mirrors the first source Observable to emit an item.
    *
    * ## Example
    * ### Subscribes to the observable that was the first to start emitting.
    *
    * ```javascript
    * const obs1 = interval(1000).pipe(mapTo('fast one'));
    * const obs2 = interval(3000).pipe(mapTo('medium one'));
    * const obs3 = interval(5000).pipe(mapTo('slow one'));
    *
    * race(obs3, obs1, obs2)
    * .subscribe(
    *   winner => console.log(winner)
    * );
    *
    * // result:
    * // a series of 'fast one'
    * ```
    *
    * @param {...Observables} ...observables sources used to race for which Observable emits first.
    * @return {Observable} an Observable that mirrors the output of the first Observable to emit an item.
    * @static true
    * @name race
    * @owner Observable
    */
export declare function race<T>(observables: Array<Observable<T>>): Observable<T>;
export declare function race<T>(observables: Array<Observable<any>>): Observable<T>;
export declare function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): Observable<T>;
export declare class RaceOperator<T> implements Operator<T, T> {
        call(subscriber: Subscriber<T>, source: any): TeardownLogic;
}
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @ignore
    * @extends {Ignored}
    */
export declare class RaceSubscriber<T> extends OuterSubscriber<T, T> {
        constructor(destination: Subscriber<T>);
        protected _next(observable: any): void;
        protected _complete(): void;
        notifyNext(outerValue: T, innerValue: T, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, T>): void;
}

import { SchedulerAction, SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
/**
  * Creates an Observable that emits a sequence of numbers within a specified
  * range.
  *
  * <span class="informal">Emits a sequence of numbers in a range.</span>
  *
  * ![](range.png)
  *
  * `range` operator emits a range of sequential integers, in order, where you
  * select the `start` of the range and its `length`. By default, uses no
  * {@link SchedulerLike} and just delivers the notifications synchronously, but may use
  * an optional {@link SchedulerLike} to regulate those deliveries.
  *
  * ## Example
  * Emits the numbers 1 to 10</caption>
  * ```javascript
  * const numbers = range(1, 10);
  * numbers.subscribe(x => console.log(x));
  * ```
  * @see {@link timer}
  * @see {@link index/interval}
  *
  * @param {number} [start=0] The value of the first integer in the sequence.
  * @param {number} [count=0] The number of sequential integers to generate.
  * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
  * the emissions of the notifications.
  * @return {Observable} An Observable of numbers that emits a finite range of
  * sequential integers.
  * @static true
  * @name range
  * @owner Observable
  */
export declare function range(start?: number, count?: number, scheduler?: SchedulerLike): Observable<number>;
/** @internal */
export declare function dispatch(this: SchedulerAction<any>, state: any): void;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Creates an Observable that emits no items to the Observer and immediately
  * emits an error notification.
  *
  * <span class="informal">Just emits 'error', and nothing else.
  * </span>
  *
  * ![](throw.png)
  *
  * This static operator is useful for creating a simple Observable that only
  * emits the error notification. It can be used for composing with other
  * Observables, such as in a {@link mergeMap}.
  *
  * ## Examples
  * ### Emit the number 7, then emit an error
  * ```javascript
  * import { throwError, concat, of } from 'rxjs';
  *
  * const result = concat(of(7), throwError(new Error('oops!')));
  * result.subscribe(x => console.log(x), e => console.error(e));
  *
  * // Logs:
  * // 7
  * // Error: oops!
  * ```
  *
  * ---
  *
  * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13
  * ```javascript
  * import { throwError, interval, of } from 'rxjs';
  * import { mergeMap } from 'rxjs/operators';
  *
  * interval(1000).pipe(
  *   mergeMap(x => x === 2
  *     ? throwError('Twos are bad')
  *     : of('a', 'b', 'c')
  *   ),
  * ).subscribe(x => console.log(x), e => console.error(e));
  *
  * // Logs:
  * // a
  * // b
  * // c
  * // a
  * // b
  * // c
  * // Twos are bad
  * ```
  *
  * @see {@link Observable}
  * @see {@link empty}
  * @see {@link never}
  * @see {@link of}
  *
  * @param {any} error The particular Error to pass to the error notification.
  * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling
  * the emission of the error notification.
  * @return {Observable} An error Observable: emits only the error notification
  * using the given error argument.
  * @static true
  * @name throwError
  * @owner Observable
  */
export declare function throwError(error: any, scheduler?: SchedulerLike): Observable<never>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { SchedulerLike } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Creates an Observable that starts emitting after an `dueTime` and
  * emits ever increasing numbers after each `period` of time thereafter.
  *
  * <span class="informal">Its like {@link index/interval}, but you can specify when
  * should the emissions start.</span>
  *
  * ![](timer.png)
  *
  * `timer` returns an Observable that emits an infinite sequence of ascending
  * integers, with a constant interval of time, `period` of your choosing
  * between those emissions. The first emission happens after the specified
  * `dueTime`. The initial delay may be a `Date`. By default, this
  * operator uses the {@link asyncScheduler} {@link SchedulerLike} to provide a notion of time, but you
  * may pass any {@link SchedulerLike} to it. If `period` is not specified, the output
  * Observable emits only one value, `0`. Otherwise, it emits an infinite
  * sequence.
  *
  * ## Examples
  * ### Emits ascending numbers, one every second (1000ms), starting after 3 seconds
  * ```javascript
  * const numbers = timer(3000, 1000);
  * numbers.subscribe(x => console.log(x));
  * ```
  *
  * ### Emits one number after five seconds
  * ```javascript
  * const numbers = timer(5000);
  * numbers.subscribe(x => console.log(x));
  * ```
  * @see {@link index/interval}
  * @see {@link delay}
  *
  * @param {number|Date} [dueTime] The initial delay time specified as a Date object or as an integer denoting
  * milliseconds to wait before emitting the first value of 0`.
  * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
  * subsequent numbers.
  * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling
  * the emission of values, and providing a notion of "time".
  * @return {Observable} An Observable that emits a `0` after the
  * `dueTime` and ever increasing numbers after each `period` of time
  * thereafter.
  * @static true
  * @name timer
  * @owner Observable
  */
export declare function timer(dueTime?: number | Date, periodOrScheduler?: number | SchedulerLike, scheduler?: SchedulerLike): Observable<number>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Unsubscribable, ObservableInput } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
  * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
  *
  * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
  *
  * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
  * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
  * that object and should return an Observable. That Observable can use resource object during its execution.
  * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
  * resource object will be shared in any way between subscriptions.
  *
  * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
  * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
  * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
  * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
  * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
  * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
  * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
  *
  * @see {@link defer}
  *
  * @param {function(): ISubscription} resourceFactory A function which creates any resource object
  * that implements `unsubscribe` method.
  * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
  * creates an Observable, that can use injected resource object.
  * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
  * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
  */
export declare function using<T>(resourceFactory: () => Unsubscribable | void, observableFactory: (resource: Unsubscribable | void) => ObservableInput<T> | void): Observable<T>;

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Operator } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Operator';
import { ObservableInput } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, R>(v1: ObservableInput<T>, resultSelector: (v1: T) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, resultSelector: (v1: T, v2: T2) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;
export declare function zip<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;
export declare function zip<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;
export declare function zip<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;
export declare function zip<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;
export declare function zip<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;
export declare function zip<T>(array: ObservableInput<T>[]): Observable<T[]>;
export declare function zip<R>(array: ObservableInput<any>[]): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<T, R>(array: ObservableInput<T>[], resultSelector: (...values: Array<T>) => R): Observable<R>;
/** @deprecated resultSelector is no longer supported, pipe to map instead */
export declare function zip<R>(array: ObservableInput<any>[], resultSelector: (...values: Array<any>) => R): Observable<R>;
export declare function zip<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;
export declare function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;
export declare function zip<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;
export declare class ZipOperator<T, R> implements Operator<T, R> {
        resultSelector: (...values: Array<any>) => R;
        constructor(resultSelector?: (...values: Array<any>) => R);
        call(subscriber: Subscriber<R>, source: any): any;
}
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @ignore
    * @extends {Ignored}
    */
export declare class ZipSubscriber<T, R> extends Subscriber<T> {
        constructor(destination: Subscriber<R>, resultSelector?: (...values: Array<any>) => R, values?: any);
        protected _next(value: any): void;
        protected _complete(): void;
        notifyInactive(): void;
        checkIterators(): void;
        protected _tryresultSelector(args: any[]): void;
}

import { Observable } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Observable';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
/** OPERATOR INTERFACES */
export interface UnaryFunction<T, R> {
    (source: T): R;
}
export interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {
}
export declare type FactoryOrValue<T> = T | (() => T);
export interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {
}
export interface Timestamp<T> {
    value: T;
    timestamp: number;
}
export interface TimeInterval<T> {
    value: T;
    interval: number;
}
/** SUBSCRIPTION INTERFACES */
export interface Unsubscribable {
    unsubscribe(): void;
}
export declare type TeardownLogic = Unsubscribable | Function | void;
export interface SubscriptionLike extends Unsubscribable {
    unsubscribe(): void;
    readonly closed: boolean;
}
export declare type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;
/** OBSERVABLE INTERFACES */
export interface Subscribable<T> {
    subscribe(observer?: PartialObserver<T>): Unsubscribable;
    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Unsubscribable;
}
export declare type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T> | Iterable<T>;
/** @deprecated use {@link InteropObservable } */
export declare type ObservableLike<T> = InteropObservable<T>;
export declare type InteropObservable<T> = {
    [Symbol.observable]: () => Subscribable<T>;
};
/** OBSERVER INTERFACES */
export interface NextObserver<T> {
    closed?: boolean;
    next: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
export interface ErrorObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error: (err: any) => void;
    complete?: () => void;
}
export interface CompletionObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete: () => void;
}
export declare type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
export interface Observer<T> {
    closed?: boolean;
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
/** SCHEDULER INTERFACES */
export interface SchedulerLike {
    now(): number;
    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
}
export interface SchedulerAction<T> extends Subscription {
    schedule(state?: T, delay?: number): Subscription;
}

/**
    * The global configuration object for RxJS, used to configure things
    * like what Promise contructor should used to create Promises
    */
export declare const config: {
        /**
            * The promise constructor used by default for methods such as
            * {@link toPromise} and {@link forEach}
            */
        Promise: PromiseConstructorLike;
        /**
            * If true, turns on synchronous error rethrowing, which is a deprecated behavior
            * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe
            * call in a try/catch block. It also enables producer interference, a nasty bug
            * where a multicast can be broken for all observers by a downstream consumer with
            * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME
            * FOR MIGRATION REASONS.
            */
        useDeprecatedSynchronousErrorHandling: boolean;
};

import { AsyncAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncAction';
import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
export declare class AsapScheduler extends AsyncScheduler {
    flush(action?: AsyncAction<any>): void;
}

import { Scheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Scheduler';
import { Action } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/Action';
import { AsyncAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncAction';
import { SchedulerAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
export declare class AsyncScheduler extends Scheduler {
        static delegate?: Scheduler;
        actions: Array<AsyncAction<any>>;
        /**
            * A flag to indicate whether the Scheduler is currently executing a batch of
            * queued actions.
            * @type {boolean}
            * @deprecated internal use only
            */
        active: boolean;
        /**
            * An internal ID used to track the latest asynchronous task such as those
            * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
            * others.
            * @type {any}
            * @deprecated internal use only
            */
        scheduled: any;
        constructor(SchedulerAction: typeof Action, now?: () => number);
        schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
        flush(action: AsyncAction<any>): void;
}

import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
export declare class QueueScheduler extends AsyncScheduler {
}

import { AsyncAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncAction';
import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
export declare class AnimationFrameScheduler extends AsyncScheduler {
    flush(action?: AsyncAction<any>): void;
}

import { Action } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/Action';
import { SchedulerAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { AsyncScheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/scheduler/AsyncScheduler';
/**
    * We need this JSDoc comment for affecting ESDoc.
    * @ignore
    * @extends {Ignored}
    */
export declare class AsyncAction<T> extends Action<T> {
        protected scheduler: AsyncScheduler;
        protected work: (this: SchedulerAction<T>, state?: T) => void;
        id: any;
        state: T;
        delay: number;
        protected pending: boolean;
        constructor(scheduler: AsyncScheduler, work: (this: SchedulerAction<T>, state?: T) => void);
        schedule(state?: T, delay?: number): Subscription;
        protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay?: number): any;
        protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay?: number): any;
        /**
            * Immediately executes this action and the `work` it contains.
            * @return {any}
            */
        execute(state: T, delay: number): any;
        protected _execute(state: T, delay: number): any;
        /** @deprecated This is an internal implementation detail, do not use. */
        _unsubscribe(): void;
}

import { Scheduler } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Scheduler';
import { Subscription } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscription';
import { SchedulerAction } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/types';
/**
    * A unit of work to be executed in a `scheduler`. An action is typically
    * created from within a {@link SchedulerLike} and an RxJS user does not need to concern
    * themselves about creating and manipulating an Action.
    *
    * ```ts
    * class Action<T> extends Subscription {
    *   new (scheduler: Scheduler, work: (state?: T) => void);
    *   schedule(state?: T, delay: number = 0): Subscription;
    * }
    * ```
    *
    * @class Action<T>
    */
export declare class Action<T> extends Subscription {
        constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void);
        /**
            * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed
            * some context object, `state`. May happen at some point in the future,
            * according to the `delay` parameter, if specified.
            * @param {T} [state] Some contextual data that the `work` function uses when
            * called by the Scheduler.
            * @param {number} [delay] Time to wait before executing the work, where the
            * time unit is implicit and defined by the Scheduler.
            * @return {void}
            */
        schedule(state?: T, delay?: number): Subscription;
}

import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { InnerSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/InnerSubscriber';
/**
  * We need this JSDoc comment for affecting ESDoc.
  * @ignore
  * @extends {Ignored}
  */
export declare class OuterSubscriber<T, R> extends Subscriber<T> {
    notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number, innerSub: InnerSubscriber<T, R>): void;
    notifyError(error: any, innerSub: InnerSubscriber<T, R>): void;
    notifyComplete(innerSub: InnerSubscriber<T, R>): void;
}

import { Subscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/Subscriber';
import { OuterSubscriber } from 'rxjs/--/--/--/--/--/node_modules/rxjs/internal/OuterSubscriber';
/**
  * We need this JSDoc comment for affecting ESDoc.
  * @ignore
  * @extends {Ignored}
  */
export declare class InnerSubscriber<T, R> extends Subscriber<R> {
    outerValue: T;
    outerIndex: number;
    constructor(parent: OuterSubscriber<T, R>, outerValue: T, outerIndex: number);
    protected _next(value: R): void;
    protected _error(error: any): void;
    protected _complete(): void;
}


}
